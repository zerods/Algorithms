###六度空间问题
六度空间”理论又称作“六度分隔（Six Degrees of Separation）”理论。这个理论可以通俗地阐述为：“你和任
何一个陌生人之间所间隔的人不会超过六个，也就是说，最多通过五个人你就能够认识任何一个陌生人。”来源：
https://pta.patest.cn/pta/test/558/exam/4/question/9497
“六度空间”理论虽然得到广泛的认同，并且正在得到越来越多的应用。但是数十年来，试图验证这个理论始终
是许多社会学家努力追求的目标。然而由于历史的原因，这样的研究具有太大的局限性和困难。随着当代人的联
络主要依赖于电话、短信、微信以及因特网上即时通信等工具，能够体现社交网络关系的一手数据已经逐渐使
得“六度空间”理论的验证成为可能。

假如给你一个社交网络图，请你对每个节点计算符合“六度空间”理论的结点占结点总数的百分比。

输入格式:

输入第1行给出两个正整数，分别表示社交网络图的结点数NN（1<N≤10000表示人数）、边数M（≤33×N，表示社交关系数）
随后的M行对应M条边，每行给出一对正整数，分别是该条边直接连通的两个结点的编号（节点从1到N编号）。

输出格式:

对每个结点输出与该结点距离不超过6的结点数占结点总数的百分比，精确到小数点后2位。每个结节点输出一行，格式
为“结点编号:（空格）百分比%”。

输入样例:

10 9

1 2

2 3

3 4

4 5

5 6

6 7

7 8

8 9

9 10
输出样例:

1: 70.00%

2: 80.00%

3: 90.00%

4: 100.00%

5: 100.00%

6: 100.00%

7: 100.00%

8: 90.00%

9: 80.00%

10: 70.00%

```c
#include <stdio.h>
#include <stdlib.h>
typedef int Vertex;
typedef Vertex ElementType;
typedef struct queueNode *ptrToQueueNode;
struct queueNode {
    ElementType queueEle;
    ptrToQueueNode next;
};

typedef struct QNode* Queue;
struct QNode {
    ptrToQueueNode head;
    ptrToQueueNode tail;
};
Queue CreateQueue() {
    Queue Q = (Queue)malloc(sizeof(struct QNode));
    Q->head = malloc(sizeof(struct queueNode));
    Q->tail = Q->head;
    Q->tail->next = NULL;
    return Q;
}

int IsEmpty(Queue Q) {
    return Q->head == Q->tail;
}

ElementType Dequeue(Queue Q) {
    ptrToQueueNode tmp;
    int value;
    if(IsEmpty(Q))
        return -1;
    tmp = Q->head->next;
    Q->head->next = tmp->next;
    value = tmp->queueEle;
    if(Q->tail == tmp)
        Q->tail = Q->head;
    free(tmp);

    return value;
}
void Enqueue(ElementType V, Queue Q) {
    ptrToQueueNode NewQueueNode;
    NewQueueNode = (ptrToQueueNode)malloc(sizeof(struct queueNode));
    NewQueueNode->queueEle = V;

    NewQueueNode->next = NULL;
    Q->tail->next = NewQueueNode;
    Q->tail = NewQueueNode;
}


#define MaxVertexNum 10001
typedef int Vertex;
typedef struct ENode *Edge;
struct ENode {
    Vertex V1;
    Vertex V2;
};

typedef struct AdjVNode *ptrToAdjVNode;
struct AdjVNode {
    Vertex name;
    ptrToAdjVNode next;
};

typedef struct Vnode {
    ptrToAdjVNode firstEdge;
}AdjList[MaxVertexNum];

typedef struct GNode *ptrToGNode;
struct GNode {
    int nv;
    int ne;
    AdjList G;
};
typedef ptrToGNode LGraph;

LGraph CreateGraph( int VertexNum ) {
    Vertex V;
    LGraph Graph;

    Graph = (LGraph)malloc(sizeof(struct GNode));
    Graph->nv = VertexNum;
    Graph->ne = 0;

    for(V=0; V<Graph->nv; V++) {
        Graph->G[V].firstEdge = NULL;
    }

    return Graph;
}

void InsertEdge( LGraph Graph, Edge E ) {
    ptrToAdjVNode NewNode1, NewNode2;
    NewNode1 = (ptrToAdjVNode)malloc(sizeof(struct AdjVNode));
    NewNode1->name = E->V2;
    NewNode1->next = Graph->G[E->V1].firstEdge;
    Graph->G[E->V1].firstEdge = NewNode1;

    NewNode2 = (ptrToAdjVNode)malloc(sizeof(struct AdjVNode));
    NewNode2->name = E->V1;
    NewNode2->next = Graph->G[E->V2].firstEdge;
    Graph->G[E->V2].firstEdge = NewNode2;
}

LGraph BuildGraph(void){
    LGraph Graph;
    Edge E;
    int nv, i;
    ptrToAdjVNode W;

    scanf("%d", &nv);
    Graph = CreateGraph(nv);
    scanf("%d", &Graph->ne);
    if (Graph->ne != 0) {
        E = (Edge)malloc(sizeof(struct ENode));
        for(i=0; i<Graph->ne; i++) {
            scanf("%d %d", &E->V1, &E->V2);
            InsertEdge(Graph, E);
        }
    }
//    for(i=1; i<=Graph->nv; i++) {
//        printf("%d ", i);
//        for(W=Graph->G[i].firstEdge; W; W=W->next )
//            printf("%d ", W->name);
//        printf("\n");
//    }
    return Graph;

}

int Visited[MaxVertexNum] = {0};

int Bfs(LGraph Graph, Vertex V) {
    Visited[V] = 1;
    int count = 1;
    int level = 0;
    int last = V;
    ptrToAdjVNode W;
    Queue Q = CreateQueue();
    int tail = 0;

    Enqueue(V, Q);
    while (!IsEmpty(Q)) {
        V = Dequeue(Q);
        for(W=Graph->G[V].firstEdge; W; W=W->next ) {
            if (!Visited[W -> name]) {
                Visited[W -> name] = 1;
                Enqueue(W->name, Q);
                count++;
                tail = W->name;  /*tail是下一层进队列的最后一个节点*/
            }
        }
        if (V == last) {        /*换层标志，本层节点都已经出列*/
            level++;
            last = tail;
        }
        if (level == 6)
            break;
    }

    return count;
}


void sds(void) {
    int V, count, i;
    LGraph Graph = BuildGraph();
    for (V=1; V<=Graph->nv; V++) {
        count = Bfs(Graph, V);
        printf("%d: %.2f%%\n", V, 100.0 * count / Graph->nv );
        for(i=1; i<=Graph->nv; i++){
            Visited[i] = 0;
        }
    }
}

int main() {
    sds();
    return 0;
}


```
