### Sort with Swap(0, i)
Given any permutation of the numbers {0, 1, 2,..., N-1}, it is easy to sort them in increasing order.
But what if Swap(0, *) is the ONLY operation that is allowed to use? For example, to sort {4, 0, 2, 1, 3}
we may apply the swap operations in the following way:

Swap(0, 1) => {4, 1, 2, 0, 3}

Swap(0, 3) => {4, 1, 2, 3, 0}

Swap(0, 4) => {0, 1, 2, 3, 4}

Now you are asked to find the minimum number of swaps need to sort the given permutation of the first N nonnegative integers.

####Input Specification:

Each input file contains one test case, which gives a positive N(N≤100000) followed by a permutation sequence of {0, 1, ..., N-1}.
All the numbers in a line are separated by a space.

####Output Specification:

For each case, simply print in a line the minimum number of swaps need to sort the given permutation.

####Sample Input:

10

3 5 7 2 6 4 9 0 8 1

####Sample Output:


9

```c
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char* argv[]) {
    //freopen("test.txt", "r", stdin);
    int i, j, N, ele;
    scanf("%d", &N);
    int A[N], B[N];
    for(i=0; i<N; i++)
        B[i] = 0;
    int orderedNum = 0;
    int swapNum = 0;
    int tmp;
  /*初始化*/
    for(i=0; i<N; i++) {
        scanf("%d", &ele);
        A[ele] = i;
        if (A[i] == i && i) {
            orderedNum++;
            B[i] = 1;
        }
    }
  /*如果元素0恰好在0位置上且序列乱序时，从位置1开始寻找还未有序的元素进行交换*/
  /*如果元素0不在0位置上，与index等于数列值的位置进行交换，并设置交换后那个位置有序，即B[index] = 1*/
    i = 1;
    while(orderedNum != N - 2 && N > 1) {
        if (A[0] == 0) {
            while(B[i++]);
            A[0] = A[--i];
            A[i] = 0;
        } else {
            tmp = A[0];
            A[0] = A[tmp];
            A[tmp] = tmp;
            B[tmp] = 1;
            orderedNum++;
        }
        swapNum++;
    }
  /*考虑单个元素*/
    if (N > 1)
        swapNum++;
    printf("%d", swapNum);

    return 0;
}
```


