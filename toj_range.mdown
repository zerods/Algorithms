#范围查询(Range)
##Description
Let S be a set of n integral points on the x-axis. For each given interval [a, b], 
you are asked to count the points lying inside.

##Input
The first line contains two integers: n (size of S) and m (the number of queries).

The second line enumerates all the n points in S.

Each of the following m lines consists of two integers a and b and defines an query interval [a, b].

##Output
The number of points in S lying inside each of the m query intervals.

##Example
Input

5 2
1 3 7 9 11
4 6
7 12

Output

0
3
##Restrictions
0 <= n, m <= 5 * 10^5

For each query interval [a, b], it is guaranteed that a <= b.

Points in S are distinct from each other.

Coordinates of each point as well as the query interval boundaries a and b are non-negative integers not greater than 10^7.

Time: 2 sec

Memory: 256 MB

```c
#include <stdio.h>
#include <stdlib.h>

int judge(int array[], int size);
int judgeIndex(int array[], int left, int right, int x);
void mergeSort(int arr[], int start, int end);
void merge(int arr[], int start, int middle, int end);

int main() {
    int i, size, queries, j = 0;
    scanf("%d %d\n", &size, &queries);
    int array[size], count[queries];
    for( i=0; i< size; i++ ) {
        scanf("%d ", &array[i]);
    }
    mergeSort(array, 0, size - 1);
    while( j < queries ) {
        count[j++] = judge(array, size);
    }
    for( j=0; j<queries; j++) {
        printf("%d\n", count[j]);
    }
    return 0;
}

int judge(int array[], int size) {
    int  a, b, count = 0, indexOfa, indexOfb;
    scanf("%d %d", &a, &b);
    if ( a > array[size - 1] || b < array[0]) {
        count = 0;
    } else if ( b >= array[size - 1] && a <= array[0]) {
        count = size;
    } else {
        indexOfa = judgeIndex(array, 0, size - 1, a);
        indexOfb = judgeIndex(array, 0, size - 1, b);
        count +=  indexOfb -  indexOfa;
        if ( array[indexOfb] == b ) {
            count++;
        }
    }
    return count;
}

int judgeIndex(int array[], int left, int right, int x) {
    int middle = ( left + right ) / 2;
    while( left - right < 1) {
        if ( x < array[middle] ) {
            right = middle - 1;
            middle = ( left + right ) / 2;
        } else if ( x > array[middle] ) {
            left = middle + 1;
            middle = ( left + right ) / 2;
        } else {
            return middle;
        }
    }
    return left;
}

void merge(int arr[], int start, int middle, int end){
    int i, j, k, length1, length2;
    int *pl, *pr;
    length1 = middle - start + 1;
    length2 = end - middle;
    pl = (int *)malloc(length1 * sizeof(int));
    pr = (int *)malloc(length2 * sizeof(int));
    for(i = 0; i < length1; i++){
        pl[i] = arr[start + i];
    }
    for(i = 0; i < length2; i++){
        pr[i] = arr[middle + 1 + i];
    }
    i = 0;
    j = 0;
    k = start;
    while(i < length1 && j < length2){
        if(pl[i] < pr[j]){
            arr[k++] = pl[i++];
        } else {
            arr[k++] = pr[j++];
            }
    }
    while(i < length1){
        arr[k++] = pl[i++];
    }
    while(j < length2){
        arr[k++] = pr[j++];
    }
}

void mergeSort(int arr[], int start, int end){
    int middle;
    if(start < end){
        middle = (end + start) / 2;
        mergeSort(arr, start, middle);
        mergeSort(arr, middle + 1, end);
        merge(arr, start, middle, end);
    }
}
```
