##pat pop-sequence problem
Given a stack which can keep MM numbers at most. Push NN numbers in the order of 1, 2, 3, ..., NN and pop randomly. You are supposed to tell if a given sequence of numbers is a possible pop sequence of the stack. For example, if MM is 5 and NN is 7, we can obtain 1, 2, 3, 4, 5, 6, 7 from the stack, but not 3, 2, 1, 7, 5, 6, 4.

Input Specification:

Each input file contains one test case. For each case, the first line contains 3 numbers (all no more than 1000): MM (the maximum capacity of the stack), NN (the length of push sequence), and KK (the number of pop sequences to be checked). Then KK lines follow, each contains a pop sequence of NN numbers. All the numbers in a line are separated by a space.

Output Specification:

For each pop sequence, print in one line "YES" if it is indeed a possible pop sequence of the stack, or "NO" if not.

Sample Input:

5 7 5
1 2 3 4 5 6 7

3 2 1 7 5 6 4

7 6 5 4 3 2 1

5 6 4 3 7 2 1

1 7 6 5 4 3 2

Sample Output:

YES

NO

NO

YES

NO

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# @Author  : zerods (gengchaosun@outlook.com)
# Filename: pat_pop_sequence_zerods.py

def judge(stackSize, pushList):
    '''
    这个函数是根据函数里通过输入得到的popList来模拟在stackList和pushList里面的

    一系列操作，根据1：栈是否溢出；2:popList的表头数据是否在栈顶 

    来判断popList是否可以通过pop和push得到
    '''

    stackList = []
    popList = raw_input().split(' ')      
    while (len(pushList) or len(popList)) and len(stackList) < stackSize:
        popEle = int(popList.pop(0))
        if inStackTop(popEle, stackList) and stackList[-1] == popEle:
            stackList.pop()
##            print stackList, pushList
        elif inStackTop(popEle, stackList) and stackList[-1] != popEle:
            return 'NO'
        else:
            while pushList[0] != popEle and len(stackList) <= stackSize:
                stackList.append(pushList.pop(0))
##                print stackList, pushList
            if pushList[0] == popEle and len(stackList) < stackSize:
                stackList.append(pushList.pop(0))
                stackList.pop(-1)
##                print stackList, pushList
            else:
                return 'NO'
    if len(stackList) == 0:
        return 'YES'
    else:
        return 'NO'

def inStackTop(popEle, stackList):
    if len(stackList) == 0:
        return False
    elif popEle in stackList:
        return True

def main():
    ansList = []
    initial = raw_input().split(' ')
    stackSize = int(initial[0])
    pushNum = int(initial[1])
    seqNum = int(initial[2])
    for i in range(seqNum):
        pushList = range(1, pushNum + 1)
        ans = judge(stackSize, pushList)
        ansList.append(ans)
    for ans in ansList:
        print ans
main()
```
